#/usr/bin/python
import re
import random
import string

class NeoepitopeMHC():

    def __init__( self, len_aa_radius ):
        self.len_aa_radius = len_aa_radius      #this is the # of amino acids to retrieve before & after 
 
    def make_full_neoep_seq( self, alt, before_aa, after_aa ):
        """
        Create the full neoepitope sequence - this entire string (neoepitope string) will be used to generate the collection of neoepitope sequences generated by this event
        Args:
            -alt = string that is the original & mutated AA, in the format "orig/mut" (e.g. A/D -> original A, mutated to D)
            -before_aa = string that is the amino acid string before alt (from the 5' end). This assumes the AA sequence has been corrected based on strand sign (meaning for + strand, these AA seq came from genomically lower position than alt, and for - strand these AA came from genomically higher position than alt)
            -after_aa = string that is the amino acid string after alt (from the 3' end). This assumes the AA sequence has been corrected based on strand sign (meaning for + strand, these AA seq came from genomically higher position than alt, and for - strand these AA came from genomically lower position than alt)
            -len_aa_before = integer that is a negative value because I want to retrieve the ending characters in the AA seq in "before_aa". When retrieving AA sequence from "after_aa", need to change "len_aa_before" to the positive value
        Returns: array where [0] = the original neoepitope sequence & [1] = the mutated neoepitope sequence
        """
        #make sure the demanded length self.len_aa_radius is shorter the AA length in 'before_aa' & 'after_aa'
        if len( before_aa ) < self.len_aa_radius or len( after_aa ) < self.len_aa_radius:
            return [None, None]

        orig_aa = None
        mut_aa = None
        #check if mutated AA is a stop codon or not. NOTE: the "X" is not an amino acid, just an indication of removal of AAs --> need to remove this
        list_alt = alt.split('/')       #[0] = the original AA, [1] = the mutated AA
        if len( list_alt ) >= 1:
            orig_aa = list_alt[0].replace('X','') if not re.search( r"[/-]", list_alt[0] ) else None
        if len( list_alt ) >= 2:
            mut_aa = list_alt[1].replace('X','') if not re.search( r"[/-]", list_alt[1] ) else None

        #retrieve the last N-mers
        prev_canon_aa = list( before_aa )[self.len_aa_radius:]
        neoep_seq_orig = ''.join( prev_canon_aa )
        neoep_seq_mut = ''.join( prev_canon_aa )

        if orig_aa:
            neoep_seq_orig += orig_aa
        if mut_aa:
            neoep_seq_mut += mut_aa

        #retrieve the AA after the mutation (based on length 'len_aa_before')
        len_aa_after = self.len_aa_radius * -1
        next_canon_aa = list( after_aa )[0:len_aa_after]
        neoep_seq_orig += ''.join( next_canon_aa )
        neoep_seq_mut += ''.join( next_canon_aa )

        #check if any * (meaning stop codons) are present
        if "*" in neoep_seq_orig:
            neoep_seq_orig = neoep_seq_orig.split("*")[0]
        if "*" in neoep_seq_orig:
            neoep_seq_mut = neoep_seq_mut.split("*")[0]

        return [neoep_seq_orig, neoep_seq_mut]

    """
    Generate Neoepitopes
    """
    def retrieve_neoepitope( self, num_aa ):
        """
        Retrieves the potential neoepitopes based on surrounding position 
        """
        pass

    ##I MAY WANT TO DELETE THIS AS I ALREADY HAVE sliding_window_neoepitope_v3()
    # def create_neoepitope_window( self, hash_orig, hash_alt, window_size ):
    #     """
    #     Returns potential neoepitopes of certain size based on 'window_size'
    #     Args:
    #         -hash_orig & hash_alt = hashes outputted from def alterations_to_neoepitope(), where k = genomic position & v = hash where k2 = 'nuc' & 'rf' & v2 = the nucleotide base & the reading frame, respectively
    #         window_size = the # of amino acids that will make up the neoepitopes
    #     """
    #     #retrieve the original & altered genomic region of interest
    #     # self.alterations_to_neoepitope( window_size )

    #     #translate both the original & the alterated hash - first combine all nucleotides together, remove all '-' (deletions), and then translate
    #     list_pos = sorted( hash_orig.keys(), reverse = True ) if self.iso_sj.strand < 0 else sorted( hash_orig.keys() )
    #     orig_seq = ''.join( [hash_orig[i]['nuc'] for i in list_pos if hash_orig[i]['nuc'] != None] )
    #     orig_aa = str( Seq(orig_seq).translate( to_stop = False ) )

    #     alt_seq = ''.join( [hash_alt[i]['nuc'] for i in list_pos if hash_alt[i]['nuc'] != None] )
    #     alt_aa = str( Seq(alt_seq).translate( to_stop = False ) )

    #     #turn AA seq into list so I can traverse it
    #     list_orig_aa = list( orig_aa )
    #     list_alt_aa = list( alt_aa )
    #     len_aa = min( [len(list_alt_aa), len(list_orig_aa)] )

    #     #go through each translated sequence, and create window
    #     slide_count = 0
    #     hash_window_mut = {}        #For the mutated peptide sequence, k = integer (assigned from slide_count), v = hash that contains neoepitope sequence & frame
    #     hash_window_orig = {}        #For the original peptide sequence, k = integer (assigned from slide_count), v = hash that contains neoepitope sequence & frame
    #     while (slide_count + window_size) <= len_aa:
    #         window_frame = str( slide_count ) + ':' + str ( (slide_count + window_size) )

    #         #for mutated peptide
    #         hash_window_mut[slide_count] = {}       #k2 = neoep_seq & window_frame, v2 = neoep_seq = neoepitope sequence & window_frame = range of window for sublist (e.g. 0:8, 1:9, 2:10)
    #         hash_window_mut[slide_count]['neoep_seq'] = ''.join( list_alt_aa[slide_count:(slide_count + window_size)] )
    #         hash_window_mut[slide_count]['window_frame'] = window_frame

    #         #for original peptide
    #         hash_window_orig[slide_count] = {}       #k2 = neoep_seq & window_frame, v2 = neoep_seq = neoepitope sequence & window_frame = range of window for sublist (e.g. 0:8, 1:9, 2:10)
    #         hash_window_orig[slide_count]['neoep_seq'] = ''.join( list_orig_aa[slide_count:(slide_count + window_size)] )
    #         hash_window_orig[slide_count]['window_frame'] = window_frame

    #         #record genomic position
    #         ##TEST:: print "slide_count = ", slide_count, " | slide_count * 3 = ", slide_count * 3, " && (slide_count + window_size) * 3 - 1 = ", (slide_count + window_size) * 3 - 1

    #         list_start_end_pos = [ list_pos[slide_count * 3], list_pos[(slide_count + window_size) * 3 - 1] ]
    #         hash_strand = {1: '+', -1: '-'}
    #         genomic_range = self.iso_sj.chrom + ':' + str( min(list_start_end_pos) ) + '-' + str( max (list_start_end_pos) ) + ' (' + hash_strand[self.iso_sj.strand] + ')'
    #         hash_window_mut[slide_count]['genomic_range'] = genomic_range
    #         hash_window_orig[slide_count]['genomic_range'] = genomic_range

    #         slide_count += 1

    #     return [hash_window_orig, hash_window_mut]

    def sliding_window_neoepitope_v3( self, neoep_seq_mut, neoep_seq_orig, window_size = None ):
        """
        Arg:
            neoep_seq = string that the neoepitope sequence (amino acid sequence. USE = extract sublists of length 'window_size'
            window_size = integer that is the "window size" - the length of each sublist, where each sublist is an array. In other words, the length of each N-mer peptide sequence
        Function: sliding window algorithm that slides across an array, retrieving a sublist of length 'window_size'
        NOTE: to calculate the number of neoepitopes generated based on sliding window algorithm. Number of epitopes = (length of amino acid sequence - length of sliding window) + 1. Examples: 4 amino acids, sliding window is 2 -> 4 - 2 + 1 = 3, 6 - 3 + 1 = 4, 17 - 9 + 1 = 9
        """
        if not window_size:
            window_size = self.len_aa_radius

        #split string into an array of amino acid characters
        list_neoep_seq_mut = list( neoep_seq_mut )
        list_neoep_seq_orig = list( neoep_seq_orig )
        len_list = len( list_neoep_seq_mut )        #regardless if mutated AA seq or original AA seq is longer, I need to extract all neoepitope possibilities from the mutated AA seq, therefore will be the length of mutated AA seq
        slide_count = 0
        hash_neoep_mut = {}        #For the mutated peptide sequence, k = integer (assigned from slide_count), v = hash that contains neoepitope sequence & frame
        hash_neoep_orig = {}        #For the original peptide sequence, k = integer (assigned from slide_count), v = hash that contains neoepitope sequence & frame
        while (slide_count + window_size) <= len_list:
            window_frame = str( slide_count ) + ':' + str ( (slide_count + window_size) )

            #for mutated peptide
            hash_neoep_mut[slide_count] = {}       #k2 = neoep_seq & window_frame, v2 = neoep_seq = neoepitope sequence & window_frame = range of window for sublist (e.g. 0:8, 1:9, 2:10)
            hash_neoep_mut[slide_count]['neoep_seq'] = ''.join( list_neoep_seq_mut[slide_count:(slide_count + window_size)] )
            hash_neoep_mut[slide_count]['window_frame'] = window_frame

            #for original peptide
            hash_neoep_orig[slide_count] = {}       #k2 = neoep_seq & window_frame, v2 = neoep_seq = neoepitope sequence & window_frame = range of window for sublist (e.g. 0:8, 1:9, 2:10)
            hash_neoep_orig[slide_count]['neoep_seq'] = ''.join( list_neoep_seq_orig[slide_count:(slide_count + window_size)] )
            hash_neoep_orig[slide_count]['window_frame'] = window_frame

            slide_count += 1

        return [hash_neoep_mut, hash_neoep_orig]


    """
    Writing neoepitopes to file
    """
    @staticmethod
    def generate_rand_alphanumeric( len ):
        """
        Function: generates a random alphanumeric code of a specific length
        """
        return ''.join( random.choice( string.ascii_uppercase + string.ascii_lowercase + string.digits ) for j in range(len) )

    @staticmethod
    def create_fasta_header( prepend_str, len_alphanumeric ):
        """
        Arg:
            -prepend_str = string to prepend in label that will be prepended to string
            -len_alphanumeric = integer that is the length of the alphanumeric string that will be created. To consider how unique the ID should be, consider 36^(len_alphanumeric)
                -36 because 26 letters in alphabet & 10 numbers, so 26 + 10 = 36
        NOTE: this is the same as "def create_header_mut()", but uses a different format for 
        Function: creates a single line of information pertaining to the mutation.
        header information: sample name, sj ID, sj read count, SJ ratio value, gene symbol, isoform ID, gene expression, gene expression percentile
        """
        key_alphanumeric = NeoepitopeMHC.generate_rand_alphanumeric( len_alphanumeric )
        fasta_header = '>' + prepend_str + '|' + key_alphanumeric

        return fasta_header

    @staticmethod
    def format_neoep_fasta( hash_neoep_mut, hash_neoep_orig, prepend_str, len_alphanumeric, line_header_extra ):
        """
        Writes neoepitopes as to compare the original peptide sequence to the mutated peptide sequence
        Args:
            -hash_neoep_mut & hash_neoep_orig = hash where #k = integer, v = another hash where k2 = neoep_seq & window_frame, v2 = neoep_seq = neoepitope sequence & window_frame = range of window for sublist (e.g. 0:8, 1:9, 2:10). NOTE that the the neoepitope sequences should all be the same length
                -these 2 hashes are made from def sliding_window_neoepitope_v3()
            -prepend_str, len_alphanumeric = these parameters are needed for def create_fasta_header()
            -line_header_extra = string that will be appended at the end of each fasta header
        Returns: returns a string that is the line formatted to be added to a fasta file
        """
        fasta_line = ""
        neoepitope_len = len( hash_neoep_mut.values()[0]['neoep_seq'] )
        line_header = NeoepitopeMHC.create_fasta_header( prepend_str, len_alphanumeric )
        line_header_extra += '|' + line_header_extra        #add "|" to separate this extra information from the rest of the header

        #write info for aberrant SJ & the number of neoantigens it produces
        for i, (k,v) in enumerate( hash_neoep_mut.iteritems() ):     #k = integer, v = another hash where k2 = neoep_seq & window_frame, v2 = neoep_seq = neoepitope sequence & window_frame = range of window for sublist (e.g. 0:8, 1:9, 2:10)

            #count the number of neoantigens (aka neoepitopes) created by aberrant SJ
            calculated_count_neoepitope = ( len(v['neoep_seq']) - neoepitope_len ) + 1         #calculates the number of neoepitopes generated based on sliding window algorithm. Number of epitopes = (length of amino acid sequence - length of sliding window) + 1. Examples: 4 amino acids, sliding window is 2 -> 4 - 2 + 1 = 3, 6 - 3 + 1 = 4, 17 - 9 + 1 = 9

            #write info for mutated peptide
            header_mut_pep = line_header + '|m' + str(k) + line_header_extra      #the "m" means mutant
            fasta_line += header_mut_pep + '|' + v['window_frame'] + '|' + str( i ) + " of " + str( calculated_count_neoepitope ) + '\n'
            fasta_line += v['neoep_seq'] + '\n'

            #write info for original peptide
            v_orig = hash_neoep_orig[k]
            header_orig_pep = line_header + '|o' + str(k) + line_header_extra     #the "o" means original
            fasta_line += header_orig_pep + '|' + v_orig['window_frame'] + '|' + str( i ) + " of " + str( calculated_count_neoepitope ) + '\n'
            fasta_line += v_orig['neoep_seq'] + '\n'

        return fasta_line